# 特权级

* CPL：代表当前程序所处的特权级，是相对于当前正在执行代码段来说的，只有当前正在执行的代码段有CPL，即CPL=DPL

* DPL：代表某一资源或者某一程序的特权级，即描述符的DPL
  * 如果是代码段，只能平级访问，即在数值上CPL=DPL，这样才能从一个程序转移到另外的程序。
  * 如果是数据段，高特权级的程序可以访问比自身CPL特权级低的DPL的数据段，即0级特权级的程序可以访问0,12,3,的数据段
* RPL：代表请求特权级，RPL是选择子的低两位数值。RPL是在大多数情况下等于CPL。但是在一些特殊情况下，RPL并不等于CPL。因为当前正在执行的程序和请求资源的程序并不一定是一个程序。例如说：用户进程需要内核读写硬盘到某个缓冲区里面，由于用户进程没有读写硬盘的权利，此时用户进程就需要陷入内核态，让内核程序去读写硬盘。此时用户进程就是请求资源的程序，而内核就是当前正在执行的程序。那么RPL的作用是什么呢？这是防止用户进程在陷入内核态的情况下故意改写内核的数据。如果用户进程提供的这个缓冲区的选择子是内核的数据段的话，由于此时是内核态，CPL为0，拥有至高无上的权利，此时内核就会自己把自己的数据区域覆盖，可能造成很严重的影响。此时RPL的作用就凸显出来了，RPL是请求特权级，当内核提供一些写数据的例程时，是可以提前将CS的RPL位修改成请求读写进程的CPL，例如用户进程CPl为3，当用户进程请求读硬盘到缓冲区，需要提供缓冲区的选择子，然后陷入内核态，此时内核程序就会将选择子的RPL位修改成栈中存储的CS的RPl位，这样在访问缓冲区DATA_DPL时，如果RPL<=DATA_DPL&&CPL<=DATA_DPL，特权级检查才会通过，但是如果用户进程提供的缓冲区选择子DPL大于自身的CPL，特权级检查就会失败，抛出GP异常

